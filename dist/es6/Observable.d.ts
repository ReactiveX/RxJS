import Observer from './Observer';
import Subscription from './Subscription';
import Scheduler from './scheduler/Scheduler';
import Subject from './Subject';
import ConnectableObservable from './ConnectableObservable';
import ObserverFactory from './ObserverFactory';
export default class Observable {
    static value: (value: any) => Observable;
    static return: (returnValue: any) => Observable;
    static fromEvent: (element: any, eventName: string, selector: Function) => Observable;
    static fromEventPattern: (addHandler: Function, removeHandler: Function, selector: Function) => Observable;
    static throw: (err: any) => Observable;
    static empty: () => Observable;
    static never: () => Observable;
    static range: (start: number, end: number) => Observable;
    static fromArray: (array: Array<any>) => Observable;
    static zip: (observables: Array<Observable>, project: (...observables: Array<Observable>) => Observable) => Observable;
    static fromPromise: (promise: Promise<any>) => Observable;
    static of: (...values: Array<any>) => Observable;
    static timer: (delay: number) => Observable;
    static interval: (interval: number) => Observable;
    filter: (predicate: (any) => boolean) => Observable;
    map: (project: (any) => any) => Observable;
    mapTo: (value: any) => Observable;
    mergeAll: (concurrent?: number) => Observable;
    flatMap: (project: any, concurrent?: number) => Observable;
    concatAll: () => Observable;
    skip: (count: number) => Observable;
    take: (count: number) => Observable;
    subscribeOn: (scheduler: Scheduler) => Observable;
    observeOn: (scheduler: Scheduler) => Observable;
    zipAll: (project: (...observables: Array<Observable>) => Observable) => Observable;
    zip: (observables: Array<Observable>, project: (...observables: Array<Observable>) => Observable) => Observable;
    merge: (observables: Array<Observable>) => Observable;
    toArray: () => Observable;
    multicast: (subjectFactory: () => Subject) => ConnectableObservable;
    publish: () => ConnectableObservable;
    reduce: (processor: (accum: any, value: any) => any, initialValue: any) => Observable;
    source: Observable;
    observerFactory: ObserverFactory;
    constructor(subscriber?: any);
    static create(subscriber: (observer: Observer) => any): Observable;
    subscriber(observer: Observer): Subscription | Function | void;
    lift(observerFactory: ObserverFactory): Observable;
    subscribe(observerOrNext: any, error?: any, complete?: any): Subscription;
    forEach(nextHandler: any): Promise<{}>;
}
